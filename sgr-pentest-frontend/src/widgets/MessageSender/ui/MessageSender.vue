<template>
  <div class="message-sender__wrapper">
    <div :class="[
      'message-sender',
      {
        'message-sender--focused': isFocused,
        'message-sender--disabled': props.disabled
      }
    ]">
      <div class="message-sender__input-row">
        <MessageInput
          ref="messageInputRef"
          v-model="message"
          :disabled="props.disabled || chatStore.isStreaming || isSending"
          @send="sendMessage"
          @focus="handleFocus"
          @blur="handleBlur"
        />

        <div class="message-sender__actions">
          <div class="send-message-button-slot">
            <SendMessageButton :is-disabled="props.disabled || isDisabled" @send="sendMessage" />
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { computed, ref, watch } from 'vue'
import { MessageInput, SendMessageButton } from '@/features/send-message'
import { useChatStore } from '@/shared/stores'
import type { Agent } from '@/shared/stores'

interface Props {
  chatId?: string | null
  currentAssistant?: Agent | null
  initialMessage?: string
  disabled?: boolean
}

const props = withDefaults(defineProps<Props>(), {
  chatId: null,
  disabled: false,
  currentAssistant: null,
  initialMessage: '',
})

const emit = defineEmits<{
  send: [message: string]
  error: [error: string]
  input: [value: string]
  focus: []
  blur: []
}>()

const chatStore = useChatStore()

const message = ref('')
const isFocused = ref(false)
const isSending = ref(false)
const messageInputRef = ref<InstanceType<typeof MessageInput> | null>(null)

const isDisabled = computed(() => {
  const hasContent = message.value?.trim()
  // Allow input when clarification is needed, even if streaming
  const isWaitingForClarification = chatStore.needsClarification
  const isActuallyStreaming = chatStore.isStreaming && !isWaitingForClarification
  return !hasContent || isActuallyStreaming || !props.currentAssistant || isSending.value
})

// Watch for initial message from parent (e.g., from EmptyState suggestions)
watch(
  () => props.initialMessage,
  (newMessage) => {
    if (newMessage) {
      message.value = newMessage
    }
  },
  { immediate: true }
)

// Emit input event when message changes
watch(
  () => message.value,
  (newValue) => {
    emit('input', newValue)
  }
)

// Watch for streaming state changes to provide user feedback
watch(
  () => chatStore.isStreaming,
  (isStreaming, wasStreaming) => {
    if (isStreaming && !wasStreaming) {
      // âœ… Clear input when streaming STARTS
      console.log('ðŸ”„ Streaming started, clearing input')
      message.value = ''
      isSending.value = false  // Reset sending state
    } else if (!isStreaming && messageInputRef.value) {
      // Focus back to input when streaming is complete
      messageInputRef.value.$el?.querySelector('textarea')?.focus()
    }
  },
)

function handleFocus() {
  isFocused.value = true
  emit('focus')
}

function handleBlur() {
  isFocused.value = false
  emit('blur')
}

async function sendMessage() {
  if (isDisabled.value) return

  const messageContent = message.value.trim()

  // âœ… Set sending state immediately
  isSending.value = true
  console.log('ðŸ“¤ Sending message, input disabled')

  // Send text message
  if (messageContent) {
    emit('send', messageContent)
    // âœ… Don't clear immediately - wait for streaming to start
    // message.value = ''
  }
}

// Expose methods for parent components if needed
defineExpose({
  focus: () => {
    messageInputRef.value?.$el?.querySelector('textarea')?.focus()
  },
  clear: () => {
    message.value = ''
  },
  insertText: (text: string) => {
    message.value = text
    // Focus on input after inserting text
    messageInputRef.value?.$el?.querySelector('textarea')?.focus()
  },
})
</script>
<style scoped lang="scss">
.message-sender__wrapper {
  width: 100%;
  max-width: 900px;
  margin: 0 auto;
  padding: 0 20px;
}

.message-sender {
  background-color: var(--brut-bg-secondary);
  border: 1px solid var(--brut-border);
  display: flex;
  padding: 8px 8px 8px 20px;
  transition: border-color 0.2s ease;
}

.message-sender--focused {
  border-color: var(--brut-accent);
}

.message-sender--disabled {
  opacity: 0.6;
  pointer-events: none;
}

.message-sender__input-row {
  display: flex;
  align-items: center;
  gap: 8px;
  width: 100%;
}

.message-sender__actions {
  display: flex;
  align-items: center;
}

:deep(.send-message-button) {
  background-color: transparent;
  border: 1px solid var(--brut-border);
  border-radius: 0;
  width: 40px;
  height: 40px;
  color: var(--brut-text);

  &:not(:disabled) {
    background-color: transparent;
    &:hover {
      background-color: var(--brut-bg-tertiary);
      border-color: var(--brut-accent);
    }
  }
}

:deep(.textarea-input) {
  color: var(--brut-text);
  font-family: 'IBM Plex Mono', monospace;
  &::placeholder {
    color: var(--brut-text-dim);
  }
}
</style>