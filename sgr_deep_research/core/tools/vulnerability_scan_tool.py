from __future__ import annotations
import asyncio
import json
import logging
from typing import TYPE_CHECKING, ClassVar, List, Dict, Any

from pydantic import Field
from sgr_deep_research.core.base_tool import BaseTool

if TYPE_CHECKING:
    from sgr_deep_research.core.models import ResearchContext

logger = logging.getLogger(__name__)

class VulnerabilityScanTool(BaseTool):
    """
    Ищет известные уязвимости для обнаруженных сетевых сервисов, используя
    локальную базу данных Exploit-DB через утилиту searchsploit. Этот инструмент
    является вторым шагом после первичной разведки.
    """
    tool_name: ClassVar[str] = "vulnerabilityscantool"

    reasoning: str = Field(
        description="Причина, по которой необходимо выполнить поиск уязвимостей."
    )
    services: List[Dict[str, Any]] = Field(
        description="Список сервисов и их версий, полученных от инструмента разведки (например, NmapTool). Ожидается список словарей с ключами 'product' и 'version'."
    )

    async def __call__(self, context: ResearchContext) -> str:
        """
        Асинхронно запускает searchsploit для каждого сервиса и агрегирует результаты.
        """
        if not self.services:
            return json.dumps({"error": "Список сервисов для анализа пуст."})

        logger.info(f"Запуск VulnerabilityScanTool для {len(self.services)} сервисов.")

        tasks = []
        for service in self.services:
            query_parts = [service.get('product', ''), service.get('version', '')]
            service_query = " ".join(filter(None, query_parts))
            if service_query:
                tasks.append(self._run_searchsploit(service_query))

        if not tasks:
            return json.dumps({"found_vulnerabilities": []})

        results = await asyncio.gather(*tasks)

        all_vulnerabilities = []
        for res in results:
            if "error" not in res:
                all_vulnerabilities.extend(res.get("results", []))

        logger.info(f"Найдено всего {len(all_vulnerabilities)} потенциальных уязвимостей.")
        return json.dumps({"found_vulnerabilities": all_vulnerabilities}, indent=2, ensure_ascii=False)

    async def _run_searchsploit(self, query: str) -> dict:
        """Запускает searchsploit для одного запроса и возвращает результат в виде словаря."""
        command = ['searchsploit', query, '--json']
        try:
            process = await asyncio.create_subprocess_exec(
                *command,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            stdout, stderr = await process.communicate()

            if process.returncode != 0:
                error_message = stderr.decode('utf-8', errors='ignore').strip()
                logger.error(f"Ошибка выполнения searchsploit для запроса '{query}': {error_message}")
                return {"error": error_message, "query": query}

            output = stdout.decode('utf-8', errors='ignore').strip()
            if not output:
                return {"results": [], "query": query}

            data = json.loads(output)
            for result in data.get("RESULTS_EXPLOIT", []):
                result["searched_for"] = query

            return {"results": data.get("RESULTS_EXPLOIT", []), "query": query}

        except FileNotFoundError:
            msg = "Команда 'searchsploit' не найдена. Убедитесь, что пакет 'exploitdb' установлен."
            logger.error(msg)
            return {"error": msg}
        except json.JSONDecodeError:
            msg = f"Не удалось распарсить JSON-вывод от searchsploit для запроса '{query}'."
            logger.error(msg)
            return {"error": msg}
        except Exception as e:
            logger.exception(f"Непредвиденная ошибка при поиске '{query}': {e}")
            return {"error": str(e), "query": query}