from __future__ import annotations
import asyncio
import json
import logging
from typing import TYPE_CHECKING, ClassVar

from pydantic import Field
from pymetasploit3.msfrpc import MsfRpcClient

from sgr_pentest.core.base_tool import BaseTool
from sgr_pentest.core.agent_config import GlobalConfig

if TYPE_CHECKING:
    from sgr_pentest.core.models import ResearchContext

logger = logging.getLogger(__name__)

class SessionInteractionTool(BaseTool):
    """
    Взаимодействует с активной сессией Metasploit (Meterpreter или shell)
    для выполнения команд на целевой машине. Используется ПОСЛЕ того,
    как ExploitationTool успешно создал сессию.
    """
    tool_name: ClassVar[str] = "sessioninteraction"

    reasoning: str = Field(
        description="Объяснение, какую информацию ты хочешь получить, выполняя эту команду."
    )
    session_id: int = Field(
        description="ID активной сессии, полученный от ExploitationTool."
    )
    command: str = Field(
        description="Команда для выполнения в сессии. Например: 'sysinfo', 'getuid', 'ls -la', 'whoami'."
    )
    timeout: int = Field(
        default=15,
        description="Максимальное время ожидания ответа от команды в секундах."
    )

    async def __call__(self, context: ResearchContext) -> str:
        """
        Подключается к msfrpcd, находит сессию и выполняет в ней команду.
        """
        logger.info(f"SessionInteractionTool: выполнение команды '{self.command}' в сессии {self.session_id}")

        config = GlobalConfig()
        msf_config = config.metasploit

        try:
            client = MsfRpcClient(
                msf_config.password,
                port=msf_config.port,
                server=msf_config.host,
                user=msf_config.user,
                ssl=msf_config.ssl
            )
        except Exception as e:
            error_msg = f"Не удалось подключиться к Metasploit RPC: {e}."
            logger.error(error_msg)
            return json.dumps({"status": "error", "message": error_msg})

        try:
            # Проверяем, существует ли сессия
            if str(self.session_id) not in client.sessions.list:
                error_msg = f"Сессия с ID {self.session_id} не найдена или уже закрыта."
                logger.error(error_msg)
                return json.dumps({"status": "error", "message": error_msg, "active_sessions": list(client.sessions.list.keys())})

            session = client.sessions.session(str(self.session_id))
            session_info = client.sessions.list[str(self.session_id)]
            session_type = session_info.get('type')

            logger.info(f"Тип сессии: {session_type}. Выполнение команды...")
            output = ""

            if session_type == 'meterpreter':
                output = await asyncio.to_thread(
                    session.run_with_output, self.command, self.timeout
                )
            elif session_type == 'shell':
                await asyncio.to_thread(session.write, self.command + '\n')
                await asyncio.sleep(2)
                output = await asyncio.to_thread(session.read)
            else:
                return json.dumps({"status": "error", "message": f"Неподдерживаемый тип сессии: {session_type}"})

            logger.info(f"Команда '{self.command}' выполнена. Длина вывода: {len(output)} байт.")

            return json.dumps({
                "status": "success",
                "session_id": self.session_id,
                "command": self.command,
                "output": output.strip()
            }, indent=2, ensure_ascii=False)

        except Exception as e:
            error_msg = f"Ошибка при взаимодействии с сессией {self.session_id}: {e}"
            logger.error(error_msg, exc_info=True)
            return json.dumps({"status": "error", "message": error_msg})