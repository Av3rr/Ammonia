from __future__ import annotations
import asyncio
import json
import logging
import docker
from docker.errors import ContainerError, ImageNotFound
from typing import TYPE_CHECKING, ClassVar

from pydantic import Field
from sgr_pentest.core.base_tool import BaseTool

if TYPE_CHECKING:
    from sgr_pentest.core.models import ResearchContext

logger = logging.getLogger(__name__)

SANDBOX_IMAGE = "python:3.11-slim"

class PythonInterpreterTool(BaseTool):
    """
    Выполняет произвольный Python-код в изолированной и безопасной среде (песочнице).
    КРАЙНЕ ВАЖНО: Код выполняется без доступа к сети и файловой системе хоста.
    Используй этот инструмент для обработки данных, вычислений, парсинга текста
    или любой другой логики, для которой нет специализированного инструмента.
    Код должен быть простым и печатать результат в stdout.
    """
    tool_name: ClassVar[str] = "pythoninterpreter"

    reasoning: str = Field(
        description="Объяснение, что именно должен делать код и зачем он нужен."
    )
    code: str = Field(
        description="Python-код для выполнения. Код ДОЛЖЕН печатать результат с помощью print()."
    )
    timeout: int = Field(
        default=30,
        description="Максимальное время выполнения кода в секундах."
    )

    def _run_in_docker(self) -> dict:
        """Синхронная функция для запуска контейнера."""
        try:
            client = docker.from_env()
            try:
                client.images.get(SANDBOX_IMAGE)
            except ImageNotFound:
                logger.info(f"Скачивание образа песочницы: {SANDBOX_IMAGE}...")
                client.images.pull(SANDBOX_IMAGE)

            container = client.containers.run(
                SANDBOX_IMAGE,
                command=["python", "-c", self.code],
                remove=True,
                mem_limit="128m",
                cpu_shares=512,
                network_mode="none",
                detach=False,
                stdout=True,
                stderr=True,
            )

            stdout = container.decode('utf-8')
            stderr = ""

            return {"status": "success", "stdout": stdout, "stderr": stderr}

        except ContainerError as e:
            logger.error(f"Ошибка выполнения кода в контейнере: {e.stderr.decode('utf-8')}")
            return {
                "status": "execution_error",
                "stdout": e.stdout.decode('utf-8') if e.stdout else "",
                "stderr": e.stderr.decode('utf-8') if e.stderr else str(e)
            }
        except Exception as e:
            logger.error(f"Ошибка при работе с Docker: {e}", exc_info=True)
            return {"status": "docker_error", "message": str(e)}

    async def __call__(self, context: ResearchContext) -> str:
        """
        Запускает выполнение кода в отдельном потоке, чтобы не блокировать event loop.
        """
        logger.info(f"PythonInterpreterTool: запуск выполнения кода (длина: {len(self.code)} символов).")

        loop = asyncio.get_running_loop()
        result = await loop.run_in_executor(None, self._run_in_docker)

        return json.dumps(result, indent=2, ensure_ascii=False)