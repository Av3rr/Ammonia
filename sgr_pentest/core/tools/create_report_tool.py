from __future__ import annotations

import json
import logging
import os
from datetime import datetime
from typing import TYPE_CHECKING, Literal

from pydantic import Field

from sgr_pentest.core.agent_config import GlobalConfig
from sgr_pentest.core.base_tool import BaseTool

if TYPE_CHECKING:
    from sgr_pentest.core.models import ResearchContext

logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)


class CreateReportTool(BaseTool):
    """
    Генерирует финальный детализированный отчет на основе ВСЕХ находок,
    зафиксированных ранее с помощью RecordFindingTool.
    Вызывай этот инструмент в самом конце, когда все шаги плана выполнены.
    """
    reasoning: str = Field(
        description="Обоснование, почему работа завершена и можно генерировать отчет."
    )
    title: str = Field(
        description="Заголовок для финального отчета."
    )
    summary: str = Field(
        description="Краткое итоговое резюме (1-2 абзаца) о проделанной работе и общем состоянии безопасности цели."
    )

    async def __call__(self, context: ResearchContext) -> str:
        reports_dir = GlobalConfig().execution.reports_dir
        os.makedirs(reports_dir, exist_ok=True)
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        safe_title = "".join(c for c in self.title if c.isalnum() or c in (" ", "-", "_"))[:50].strip()
        filename = f"{timestamp}_{safe_title}.md"
        filepath = os.path.join(reports_dir, filename)


        report_content = []
        report_content.append(f"# {self.title}")
        report_content.append(f"**Дата генерации:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        report_content.append(f"**Цель:** {context.task}") # Предполагаем, что context.task это цель

        report_content.append("\n## 1. Итоговое резюме\n")
        report_content.append(self.summary)

        report_content.append("\n## 2. Обнаруженные уязвимости\n")

        if not context.findings:
            report_content.append("В ходе тестирования не было обнаружено ни одной уязвимости.")
        else:
            severity_order = {"Critical": 5, "High": 4, "Medium": 3, "Low": 2, "Informational": 1}
            sorted_findings = sorted(context.findings, key=lambda f: severity_order.get(f.severity, 0), reverse=True)

            for i, finding in enumerate(sorted_findings, 1):
                report_content.append(f"\n### 2.{i} {finding.description}\n")
                report_content.append(f"**Критичность:** {finding.severity}\n")

                report_content.append("**Рекомендация по устранению:**\n")
                report_content.append(f"> {finding.recommendation.replace(chr(10), ' ')}\n") # Форматируем как цитату

                report_content.append("**Доказательство (Evidence):**\n")
                report_content.append("```")
                report_content.append(finding.evidence.strip())
                report_content.append("```")

        full_report = "\n".join(report_content)
        with open(filepath, "w", encoding="utf-8") as f:
            f.write(full_report)

        logger.info(f"Отчет с {len(context.findings)} находками сгенерирован и сохранен в: {filepath}")

        return json.dumps({
            "status": "success",
            "filepath": filepath,
            "findings_count": len(context.findings)
        }, indent=2)